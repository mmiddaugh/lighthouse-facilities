<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PathEncoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">facilities-api</a> &gt; <a href="index.source.html" class="el_package">gov.va.api.lighthouse.facilities.api.pssg</a> &gt; <span class="el_source">PathEncoder.java</span></div><h1>PathEncoder.java</h1><pre class="source lang-java linenums">package gov.va.api.lighthouse.facilities.api.pssg;

import java.awt.geom.Path2D;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Base64;
import java.util.List;
import java.util.zip.Deflater;
import java.util.zip.Inflater;
import lombok.AllArgsConstructor;
import lombok.NonNull;
import lombok.SneakyThrows;

/**
 * The Path Encoder provides a very tight serialization mechanism for PSSG drive time band data. It
 * allows serialization of {@link PssgDriveTimeBand} that can be deserialized directly to Java
 * Path2D objects.
 *
 * &lt;p&gt;Serialization uses a binary collection of integer values.
 *
 * &lt;pre&gt;
 *   raw := {magic-token}{version}{number-rings}{ring ...}
 *   ring := {number-coords}{coord ...}
 *   coord := {scaled-longitude}{scaled-latitude}
 *   magic-token := {int} First byte used to verify this array is understood
 *   version := {int} Indicates the version of binary data format
 *   number-rings := {int} The number of ring structures
 *   number-coords := {int} The number of coordinate structures
 *   scaled-longitude := {int} Floating point value multiple by 10000
 *   scaled-latitude := {int} Floating point value multiple by 10000
 *   {int} := 4 bytes
 *
 *   Scaled values can be divided by 10000.0 to return to double with precision 5.
 * &lt;/pre&gt;
 */
@AllArgsConstructor(staticName = &quot;create&quot;)
public class PathEncoder {
  /**
   * The amount of space required in a ByteBuffer for an integer value. This is used to determine
   * the required buffer size.
   */
<span class="fc" id="L42">  private static int BYTES_PER_INT = 4;</span>

  /** Random number to indicate the binary packet type. */
<span class="fc" id="L45">  private static int MAGIC_NUMBER = 37337;</span>

  /**
   * The current version of encoding. Should a new information be needed, this version will be
   * incremented and backwards compatibility will be need to be maintained.
   */
<span class="fc" id="L51">  private static int VERSION = 1;</span>

  /**
   * Scaling factor applied to floating point values to integers. Since lat long values range
   * between -180 and 180, there is no concern of integer overflow.
   */
<span class="fc" id="L57">  private static int SCALE = 100000;</span>

  private static int scale(double value) {
<span class="fc" id="L60">    return (int) (value * SCALE);</span>
  }

  private static double unscale(int scaledValue) {
<span class="fc" id="L64">    return (double) scaledValue / (double) SCALE;</span>
  }

  private void check(boolean condition, String message) {
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">    if (!condition) {</span>
<span class="nc" id="L69">      throw new PathEncodingException(message);</span>
    }
<span class="fc" id="L71">  }</span>

  private byte[] compress(byte[] data) {
<span class="fc" id="L74">    Deflater compressor = new Deflater();</span>
<span class="fc" id="L75">    compressor.setInput(data);</span>
<span class="fc" id="L76">    compressor.finish();</span>
<span class="fc" id="L77">    byte[] compressed = new byte[data.length];</span>
<span class="fc" id="L78">    int size = compressor.deflate(compressed);</span>
<span class="fc" id="L79">    return Arrays.copyOf(compressed, size);</span>
  }

  private Path2D decode(byte[] compressPath) {
<span class="fc" id="L83">    byte[] pathData = decompress(compressPath);</span>
<span class="fc" id="L84">    ByteBuffer buffer = ByteBuffer.wrap(pathData);</span>
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">    check(buffer.getInt() == MAGIC_NUMBER, &quot;Unknown magic number&quot;);</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">    check(buffer.getInt() == VERSION, &quot;Unsupported version&quot;);</span>
    /*
     * In the future, should a new format be required, the existing version MUST continue to be
     * supported. Database entries will already exist and we will need to keep supporting them.
     * Should that day come, this is where we'd switch deserializers on version number.
     */
<span class="fc" id="L92">    int numberOfRings = buffer.getInt();</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">    check(numberOfRings &gt; 0, &quot;Number of rings&quot;);</span>
<span class="fc" id="L94">    Path2D path = new Path2D.Double();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">    for (int ringNumber = 0; ringNumber &lt; numberOfRings; ringNumber++) {</span>
<span class="fc" id="L96">      int numberOfCoordinates = buffer.getInt();</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">      check(</span>
          numberOfCoordinates &gt; 0,
          &quot;Number of coordinates for ring &quot; + ringNumber + &quot;: &quot; + numberOfCoordinates);
<span class="fc bfc" id="L100" title="All 2 branches covered.">      for (int coordNumber = 0; coordNumber &lt; numberOfCoordinates; coordNumber++) {</span>
<span class="fc" id="L101">        int scaledLong = buffer.getInt();</span>
<span class="fc" id="L102">        int scaledLat = buffer.getInt();</span>
<span class="fc" id="L103">        double longitude = unscale(scaledLong);</span>
<span class="fc" id="L104">        double latitude = unscale(scaledLat);</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (coordNumber == 0) {</span>
<span class="fc" id="L106">          path.moveTo(longitude, latitude);</span>
        } else {
<span class="fc" id="L108">          path.lineTo(longitude, latitude);</span>
        }
      }
<span class="fc" id="L111">      path.closePath();</span>
    }
<span class="fc" id="L113">    return path;</span>
  }

  /**
   * Decode a Path from Base 64 encoded binary representation created by {@link
   * #encodeToBase64(PssgDriveTimeBand)}.
   */
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">  public Path2D decodeFromBase64(@NonNull String path64) {</span>
<span class="fc" id="L121">    return decode(Base64.getDecoder().decode(path64));</span>
  }

<span class="nc" id="L124">  @SneakyThrows</span>
  private byte[] decompress(byte[] compressedData) {
    /*
     * When deserializing, we have to estimate how much space we need. According to zlib, typical
     * compression is between 2:1 to 5:1. (https://zlib.net/zlib_tech.html) We'll choose 10:1.
     */
<span class="fc" id="L130">    byte[] uncompressed = new byte[compressedData.length * 10];</span>
<span class="fc" id="L131">    Inflater uncompressor = new Inflater();</span>
<span class="fc" id="L132">    uncompressor.setInput(compressedData);</span>
<span class="fc" id="L133">    int size = uncompressor.inflate(uncompressed);</span>
<span class="fc" id="L134">    uncompressor.end();</span>
<span class="fc" id="L135">    return Arrays.copyOf(uncompressed, size);</span>
  }

<span class="pc bpc" id="L138" title="1 of 2 branches missed.">  private byte[] encode(@NonNull PssgDriveTimeBand band) {</span>
<span class="fc" id="L139">    ByteBuffer buffer = ByteBuffer.allocate(sizeOf(band));</span>
<span class="fc" id="L140">    buffer.putInt(MAGIC_NUMBER);</span>
<span class="fc" id="L141">    buffer.putInt(VERSION);</span>
    /*
     * Encoding only needs to support the latest version. Should a format change be required in the
     * future, it can replace this format encoding, but decoding will still need to handle both.
     */
<span class="fc" id="L146">    buffer.putInt(band.geometry().rings().size());</span>
<span class="fc" id="L147">    band.geometry()</span>
<span class="fc" id="L148">        .rings()</span>
<span class="fc" id="L149">        .forEach(</span>
            ring -&gt; {
<span class="fc" id="L151">              buffer.putInt(ring.size());</span>
<span class="fc" id="L152">              ring.forEach(</span>
                  coords -&gt; {
<span class="fc" id="L154">                    int scaledLong = scale(coords.get(0));</span>
<span class="fc" id="L155">                    int scaledLat = scale(coords.get(1));</span>
<span class="fc" id="L156">                    buffer.putInt(scaledLong);</span>
<span class="fc" id="L157">                    buffer.putInt(scaledLat);</span>
<span class="fc" id="L158">                  });</span>
<span class="fc" id="L159">            });</span>
<span class="fc" id="L160">    return compress(buffer.array());</span>
  }

  /** Encode a drive time band into a base 64 binary string that can be decoded into a Path. */
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">  public String encodeToBase64(@NonNull PssgDriveTimeBand band) {</span>
<span class="fc" id="L165">    return Base64.getEncoder().encodeToString(encode(band));</span>
  }

  /** Compute the amount of uncompressed space that will be required to serialize the band. */
  private int sizeOf(PssgDriveTimeBand band) {
<span class="fc" id="L170">    int sizeOfRings = band.geometry().rings().stream().mapToInt(this::sizeOfRing).sum();</span>
    // magic-token + version +  number-rings + sizeOfRings
<span class="fc" id="L172">    return BYTES_PER_INT + BYTES_PER_INT + BYTES_PER_INT + sizeOfRings;</span>
  }

  private int sizeOfRing(List&lt;List&lt;Double&gt;&gt; ring) {
    // number-coords + (coords lat and long)
<span class="fc" id="L177">    return BYTES_PER_INT + BYTES_PER_INT * ring.size() * 2;</span>
  }

  /** Should something go wrong ... you get this. */
  public static final class PathEncodingException extends RuntimeException {
    public PathEncodingException(String message) {
<span class="nc" id="L183">      super(message);</span>
<span class="nc" id="L184">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>