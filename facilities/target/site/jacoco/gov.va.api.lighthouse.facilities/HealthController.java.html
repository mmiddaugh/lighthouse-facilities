<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HealthController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">facilities</a> &gt; <a href="index.source.html" class="el_package">gov.va.api.lighthouse.facilities</a> &gt; <span class="el_source">HealthController.java</span></div><h1>HealthController.java</h1><pre class="source lang-java linenums">package gov.va.api.lighthouse.facilities;

import static com.google.common.base.Preconditions.checkState;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import gov.va.api.health.autoconfig.configuration.JacksonConfig;
import gov.va.api.lighthouse.facilities.collector.InsecureRestTemplateProvider;
import java.sql.Timestamp;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.Status;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.ResourceAccessException;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

<span class="fc" id="L40">@Slf4j</span>
@RestController
@RequestMapping(produces = &quot;application/json&quot;)
public class HealthController {
  private final FacilityRepository repository;

  private final InsecureRestTemplateProvider insecureRestTemplateProvider;

  private final JdbcTemplate jdbcTemplate;

  private final String atcBaseUrl;

  private final String atpBaseUrl;

  private final String cemeteriesBaseUrl;

<span class="fc" id="L56">  private final AtomicBoolean hasCachedCollectorBackend = new AtomicBoolean(false);</span>

<span class="fc" id="L58">  private final AtomicBoolean hasCachedCollectionStatus = new AtomicBoolean(false);</span>

  HealthController(
      @Autowired FacilityRepository repository,
      @Autowired InsecureRestTemplateProvider insecureRestTemplateProvider,
      @Autowired JdbcTemplate jdbcTemplate,
      @Value(&quot;${access-to-care.url}&quot;) String atcBaseUrl,
      @Value(&quot;${access-to-pwt.url}&quot;) String atpBaseUrl,
<span class="fc" id="L66">      @Value(&quot;${cemeteries.url}&quot;) String cemeteriesBaseUrl) {</span>
<span class="fc" id="L67">    this.repository = repository;</span>
<span class="fc" id="L68">    this.insecureRestTemplateProvider = insecureRestTemplateProvider;</span>
<span class="fc" id="L69">    this.jdbcTemplate = jdbcTemplate;</span>
<span class="fc" id="L70">    this.atcBaseUrl = withTrailingSlash(atcBaseUrl);</span>
<span class="fc" id="L71">    this.atpBaseUrl = withTrailingSlash(atpBaseUrl);</span>
<span class="fc" id="L72">    this.cemeteriesBaseUrl = withTrailingSlash(cemeteriesBaseUrl);</span>
<span class="fc" id="L73">  }</span>

  private static Health testHealth(
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">      @NonNull Instant now,</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">      @NonNull RestTemplate restTemplate,</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">      @NonNull String name,</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">      @NonNull String url) {</span>
    HttpStatus statusCode;
    try {
<span class="fc" id="L82">      statusCode =</span>
          restTemplate
<span class="fc" id="L84">              .exchange(url, HttpMethod.GET, new HttpEntity&lt;&gt;(new HttpHeaders()), String.class)</span>
<span class="fc" id="L85">              .getStatusCode();</span>
<span class="nc" id="L86">    } catch (ResourceAccessException e) {</span>
<span class="nc" id="L87">      log.info(&quot;Exception occurred. GET {} message: {}&quot;, url, e.getMessage());</span>
<span class="nc" id="L88">      statusCode = HttpStatus.SERVICE_UNAVAILABLE;</span>
<span class="fc" id="L89">    }</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">    return Health.status(new Status(statusCode.is2xxSuccessful() ? &quot;UP&quot; : &quot;DOWN&quot;, name))</span>
<span class="fc" id="L91">        .withDetail(&quot;name&quot;, name)</span>
<span class="fc" id="L92">        .withDetail(&quot;statusCode&quot;, statusCode.value())</span>
<span class="fc" id="L93">        .withDetail(&quot;status&quot;, statusCode)</span>
<span class="fc" id="L94">        .withDetail(&quot;time&quot;, now)</span>
<span class="fc" id="L95">        .build();</span>
  }

  private static Health testHealthJsonList(
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">      @NonNull Instant now,</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">      @NonNull RestTemplate restTemplate,</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">      @NonNull String name,</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">      @NonNull String url) {</span>
    HttpStatus statusCode;
    try {
<span class="fc" id="L105">      ResponseEntity&lt;String&gt; response =</span>
<span class="fc" id="L106">          restTemplate.exchange(</span>
              url, HttpMethod.GET, new HttpEntity&lt;&gt;(new HttpHeaders()), String.class);
<span class="fc" id="L108">      statusCode = response.getStatusCode();</span>
<span class="fc" id="L109">      JsonNode root = JacksonConfig.createMapper().readTree(response.getBody());</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">      checkState(!((ArrayNode) root).isEmpty(), &quot;No %s entries&quot;, name);</span>
<span class="fc" id="L111">    } catch (RestClientException | JsonProcessingException | IllegalArgumentException e) {</span>
<span class="fc" id="L112">      log.info(</span>
<span class="fc" id="L113">          &quot;{} occurred. GET {} message: {}&quot;, e.getClass().getSimpleName(), url, e.getMessage());</span>
<span class="fc" id="L114">      statusCode = HttpStatus.SERVICE_UNAVAILABLE;</span>
<span class="fc" id="L115">    }</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">    return Health.status(new Status(statusCode.is2xxSuccessful() ? &quot;UP&quot; : &quot;DOWN&quot;, name))</span>
<span class="fc" id="L117">        .withDetail(&quot;name&quot;, name)</span>
<span class="fc" id="L118">        .withDetail(&quot;statusCode&quot;, statusCode.value())</span>
<span class="fc" id="L119">        .withDetail(&quot;status&quot;, statusCode)</span>
<span class="fc" id="L120">        .withDetail(&quot;time&quot;, now)</span>
<span class="fc" id="L121">        .build();</span>
  }

<span class="pc bpc" id="L124" title="1 of 2 branches missed.">  private static String withTrailingSlash(@NonNull String url) {</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">    return url.endsWith(&quot;/&quot;) ? url : url + &quot;/&quot;;</span>
  }

  /** Clear cache every 5 minutes. */
  @Scheduled(cron = &quot;0 */5 * * * *&quot;)
  @CacheEvict(value = &quot;collection-status&quot;)
  public void clearCollectionStatusScheduler() {
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">    if (hasCachedCollectionStatus.getAndSet(false)) {</span>
      // reduce log spam by only reporting cleared if we've actually cached something
<span class="nc" id="L134">      log.info(&quot;Clearing facilities-collection-status cache&quot;);</span>
    }
<span class="fc" id="L136">  }</span>

  /** Clear cache every 5 minutes. */
  @Scheduled(cron = &quot;0 */5 * * * *&quot;)
  @CacheEvict(value = &quot;collector-backend-health&quot;)
  public void clearCollectorBackendHealthScheduler() {
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">    if (hasCachedCollectorBackend.getAndSet(false)) {</span>
      // reduce log spam by only reporting cleared if we've actually cached something
<span class="nc" id="L144">      log.info(&quot;Clearing facilities-collector-backend-health cache&quot;);</span>
    }
<span class="fc" id="L146">  }</span>

  /** Get health of last facilities reload. */
  @Cacheable(&quot;collection-status&quot;)
  @GetMapping(&quot;/collection/status&quot;)
  public ResponseEntity&lt;Health&gt; collectionStatusHealth() {
<span class="fc" id="L152">    hasCachedCollectionStatus.set(true);</span>
<span class="fc" id="L153">    Instant now = Instant.now();</span>
<span class="fc" id="L154">    Health reloadLastUpdatedHealth = testReloadLastUpdated(now);</span>
<span class="fc" id="L155">    log.info(reloadLastUpdatedHealth.toString());</span>
    HttpStatus httpStatus =
<span class="fc bfc" id="L157" title="All 2 branches covered.">        reloadLastUpdatedHealth.getStatus().equals(Status.UP)</span>
<span class="fc" id="L158">            ? HttpStatus.OK</span>
<span class="fc" id="L159">            : HttpStatus.SERVICE_UNAVAILABLE;</span>
<span class="fc" id="L160">    return ResponseEntity.status(httpStatus).body(reloadLastUpdatedHealth);</span>
  }

  /**
   * Gets health of collector backend systems.
   *
   * &lt;p&gt;To ensure we are not introducing too much load on downstream systems, cache the results,
   * limiting interactions to once every five minutes.
   *
   * &lt;p&gt;Spring Cacheable is used to record the result. Periodically we invalidate the cache.
   */
  @Cacheable(&quot;collector-backend-health&quot;)
  @GetMapping(value = &quot;/collector/health&quot;)
  public ResponseEntity&lt;Health&gt; collectorBackendHealth() {
<span class="fc" id="L174">    hasCachedCollectorBackend.set(true);</span>
<span class="fc" id="L175">    var now = Instant.now();</span>
<span class="fc" id="L176">    RestTemplate insecureTemplate = insecureRestTemplateProvider.restTemplate();</span>

<span class="fc" id="L178">    List&lt;Health&gt; healths = new ArrayList&lt;&gt;(5);</span>
<span class="fc" id="L179">    healths.add(</span>
<span class="fc" id="L180">        testHealthJsonList(</span>
            now,
            insecureTemplate,
            &quot;Access to Care&quot;,
<span class="fc" id="L184">            UriComponentsBuilder.fromHttpUrl(atcBaseUrl + &quot;atcapis/v1.1/patientwaittimes&quot;)</span>
<span class="fc" id="L185">                .toUriString()));</span>
<span class="fc" id="L186">    healths.add(</span>
<span class="fc" id="L187">        testHealthJsonList(</span>
            now,
            insecureTemplate,
            &quot;Access to PWT&quot;,
<span class="fc" id="L191">            UriComponentsBuilder.fromHttpUrl(atpBaseUrl + &quot;Shep/getRawData&quot;)</span>
<span class="fc" id="L192">                .queryParam(&quot;location&quot;, &quot;FL&quot;)</span>
<span class="fc" id="L193">                .build()</span>
<span class="fc" id="L194">                .toUriString()));</span>
<span class="fc" id="L195">    healths.add(</span>
<span class="fc" id="L196">        testHealth(</span>
            now,
            insecureTemplate,
            &quot;State Cemeteries&quot;,
<span class="fc" id="L200">            UriComponentsBuilder.fromHttpUrl(cemeteriesBaseUrl + &quot;cems/cems.xml&quot;).toUriString()));</span>
<span class="fc" id="L201">    healths.add(testEtlLastUpdated(now));</span>

<span class="fc" id="L203">    Health overallHealth =</span>
<span class="fc" id="L204">        Health.status(</span>
                new Status(
<span class="fc bfc" id="L206" title="All 2 branches covered.">                    healths.stream().anyMatch(h -&gt; h.getStatus().equals(Status.DOWN))</span>
<span class="fc" id="L207">                        ? &quot;DOWN&quot;</span>
<span class="fc" id="L208">                        : &quot;UP&quot;,</span>
                    &quot;Downstream services&quot;))
<span class="fc" id="L210">            .withDetail(&quot;name&quot;, &quot;All downstream services&quot;)</span>
<span class="fc" id="L211">            .withDetail(&quot;downstreamServices&quot;, healths)</span>
<span class="fc" id="L212">            .withDetail(&quot;time&quot;, now)</span>
<span class="fc" id="L213">            .build();</span>
<span class="fc" id="L214">    log.info(overallHealth.toString());</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">    if (!overallHealth.getStatus().equals(Status.UP)) {</span>
<span class="fc" id="L216">      return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(overallHealth);</span>
    }
<span class="fc" id="L218">    return ResponseEntity.ok(overallHealth);</span>
  }

<span class="pc bpc" id="L221" title="1 of 2 branches missed.">  private Health testEtlLastUpdated(@NonNull Instant now) {</span>
<span class="fc" id="L222">    Instant lastUpdated =</span>
<span class="fc" id="L223">        Optional.ofNullable(</span>
<span class="fc" id="L224">                jdbcTemplate.queryForObject(</span>
                    &quot;SELECT MAX(LASTUPDATED) FROM App.Vast&quot;, Timestamp.class))
<span class="fc" id="L226">            .map(t -&gt; t.toInstant())</span>
<span class="fc" id="L227">            .orElse(null);</span>

<span class="fc bfc" id="L229" title="All 2 branches covered.">    if (lastUpdated == null) {</span>
<span class="fc" id="L230">      return Health.status(new Status(&quot;DOWN&quot;, &quot;ETL process succeeded in the last 24 hours&quot;))</span>
<span class="fc" id="L231">          .withDetail(&quot;name&quot;, &quot;Facilities ETL process&quot;)</span>
<span class="fc" id="L232">          .withDetail(&quot;time&quot;, now)</span>
<span class="fc" id="L233">          .build();</span>
    } else {
<span class="fc" id="L235">      Instant twentyFourHoursEarlier = now.minus(24, ChronoUnit.HOURS);</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">      String statusCode = !lastUpdated.isBefore(twentyFourHoursEarlier) ? &quot;UP&quot; : &quot;DOWN&quot;;</span>

<span class="fc" id="L238">      return Health.status(new Status(statusCode, &quot;ETL process succeeded in the last 24 hours&quot;))</span>
<span class="fc" id="L239">          .withDetail(&quot;name&quot;, &quot;Facilities ETL process&quot;)</span>
<span class="fc" id="L240">          .withDetail(&quot;time&quot;, now)</span>
<span class="fc" id="L241">          .withDetail(&quot;lastUpdated&quot;, lastUpdated)</span>
<span class="fc" id="L242">          .build();</span>
    }
  }

<span class="pc bpc" id="L246" title="1 of 2 branches missed.">  private Health testReloadLastUpdated(@NonNull Instant now) {</span>
<span class="fc" id="L247">    Instant lastSuccessfulUpdate = repository.findLastUpdated();</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">    if (lastSuccessfulUpdate == null) {</span>
<span class="fc" id="L249">      return Health.status(new Status(&quot;DOWN&quot;, &quot;Facilities Collection&quot;))</span>
<span class="fc" id="L250">          .withDetail(&quot;name&quot;, &quot;Facilities Collection&quot;)</span>
<span class="fc" id="L251">          .withDetail(&quot;time&quot;, now)</span>
<span class="fc" id="L252">          .build();</span>
    }
<span class="fc" id="L254">    Instant oldestValidDate = now.minus(24, ChronoUnit.HOURS);</span>
<span class="fc" id="L255">    boolean isOutOfDate = oldestValidDate.isAfter(lastSuccessfulUpdate);</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">    return Health.status(new Status(!isOutOfDate ? &quot;UP&quot; : &quot;DOWN&quot;, &quot;Facilities Collection&quot;))</span>
<span class="fc" id="L257">        .withDetail(&quot;name&quot;, &quot;Facilities Collection&quot;)</span>
<span class="fc" id="L258">        .withDetail(&quot;lastUpdated&quot;, lastSuccessfulUpdate)</span>
<span class="fc" id="L259">        .withDetail(&quot;time&quot;, now)</span>
<span class="fc" id="L260">        .build();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>